import UIKit

/*1. Придумать класс, методы которого могут завершаться неудачей и возвращать либо значение, либо ошибку Error?. Реализовать их вызов и обработать результат метода при помощи конструкции if let, или guard let.
2. Придумать класс, методы которого могут выбрасывать ошибки. Реализуйте несколько throws-функций. Вызовите их и обработайте результат вызова при помощи конструкции try/catch.*/

enum operationCardError: Error {
    case insufficientFunds (depositMoney: Double)
    case bankBlockedCard
}

struct purchase {
    var price: Double
}
class operationCard {
    let limitCard: Double = -90000.00
    var balanceCard: Double = 0.00
    var cardBlock: Bool = false 
    
    func buySomething(purchase: purchase)throws {
        guard cardBlock == false else {
            throw operationCardError.bankBlockedCard
        }
        guard purchase.price <= (-limitCard + self.balanceCard) else {
            if balanceCard < 0 {
                throw operationCardError.insufficientFunds(depositMoney: purchase.price + limitCard + balanceCard)
            }else{
                throw operationCardError.insufficientFunds(depositMoney: purchase.price + limitCard - balanceCard)
            }
        }
        balanceCard = self.balanceCard - purchase.price
    }
}

extension operationCardError: CustomStringConvertible {
    var description: String {
        switch self {
        case .insufficientFunds(let depositMoney): return "На карте недостаточно денег для проведения этой операции."
        case .bankBlockedCard: return "Ваша карта заблокирована. За дополнительной информацией обращайтесь в Банк."
        }
    }
}

let operationBuy = operationCard()
do {
    try operationBuy.buySomething(purchase: .init(price: 100000))
} catch let error as operationCardError {
    print(error.description)
}
